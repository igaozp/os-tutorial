*你可能想提前 Google 的概念：C 类型和结构体、包含保护、类型属性：packed、extern、volatile、异常*

**目标：设置中断描述符表以处理 CPU 中断**

这节课和接下来的课程受到了 [JamesM 的教程](https://web.archive.org/web/20160412174753/http://www.jamesmolloy.co.uk/tutorial_html/index.html) 的大量启发

数据类型
----------

首先，我们将在 `cpu/types.h` 中定义一些特殊的数据类型，这将帮助我们将原始字节的数据结构与 char 和 int 解耦。它被小心地放置在 `cpu/` 文件夹中，从现在开始我们将在那里放置机器相关的代码。是的，引导代码是专门针对 x86 的，仍然在 `boot/` 中，但现在让我们不要管它。

一些已经存在的文件已经更改为使用新的 `u8`、`u16` 和 `u32` 数据类型。

从现在开始，我们的 C 头文件也将有包含保护。


中断
----------

中断是内核需要处理的主要事情之一。我们将尽快实现它，以便在未来的课程中能够接收键盘输入。

中断的其他例子有：除以零、越界、无效操作码、页面错误等。

中断在一个向量上处理，其条目类似于 GDT 的条目（第 9 课）。然而，我们将用 C 而不是汇编来编程 IDT。

`cpu/idt.h` 定义了如何存储 idt 条目 `idt_gate`（需要有 256 个，即使是空的，否则 CPU 可能会崩溃）和 BIOS 将加载的实际 idt 结构，`idt_register`，它只是一个内存地址和一个大小，类似于 GDT 寄存器。

最后，我们定义了几个变量来从汇编代码访问这些数据结构。

`cpu/idt.c` 只是用处理程序填充每个结构体。正如你所看到的，这是一个设置结构体值并调用 `lidt` 汇编命令的问题。


ISRs
----

中断服务例程在 CPU 检测到中断时运行，这通常是致命的。

我们将编写足够的代码来处理它们，打印错误消息，并停止 CPU。

在 `cpu/isr.h` 中，我们手动定义了 32 个。它们被声明为 `extern`，因为它们将在汇编中实现，在 `cpu/interrupt.asm` 中

在跳转到汇编代码之前，查看 `cpu/isr.c`。正如你所看到的，我们定义了一个函数来一次安装所有 isr 并加载 IDT，一个错误消息列表，以及高级处理程序，它 kprint 一些信息。你可以自定义 `isr_handler` 来打印/做你想做的任何事情。

现在到将每个 `idt_gate` 与其低级和高级处理程序粘合在一起的低级部分。打开 `cpu/interrupt.asm`。在这里我们定义了一个通用的低级 ISR 代码，它基本上保存/恢复状态并调用 C 代码，然后是在 `cpu/isr.h` 上引用的实际 ISR 汇编函数

注意 `registers_t` 结构体是我们在 `interrupt.asm` 中推送的所有寄存器的表示

基本上就是这样。现在我们需要从我们的 Makefile 引用 `cpu/interrupt.asm`，并让内核安装 ISR 并启动其中一个。注意即使在某些中断之后停止 CPU 是一个好习惯，CPU 也不会停止。
