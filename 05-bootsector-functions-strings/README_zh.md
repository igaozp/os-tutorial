*你可能想提前 Google 的概念：控制结构、函数调用、字符串*

**目标：学习如何用汇编器编写基本代码（循环、函数）**

我们接近最终的引导扇区了。

在第 7 课中，我们将开始从磁盘读取，这是加载内核之前的最后一步。但首先，我们将编写一些包含控制结构、函数调用和完整字符串使用的代码。在跳到磁盘和内核之前，我们真的需要对这些概念感到舒适。


字符串
-------

像字节一样定义字符串，但用空字节（是的，像 C 一样）终止它们，以便能够确定它们的结尾。

```nasm
mystring:
    db 'Hello, World', 0
```

请注意，用引号括起来的文本由汇编器转换为 ASCII，而那个单独的零将作为字节 `0x00`（空字节）传递


控制结构
------------------

我们已经使用过一个：`jmp $` 用于无限循环。

汇编跳转由*前一个*指令结果定义。例如：

```nasm
cmp ax, 4      ; 如果 ax = 4
je ax_is_four  ; 做某事（通过跳转到该标签）
jmp else       ; 否则，做另一件事
jmp endif      ; 最后，恢复正常流程

ax_is_four:
    .....
    jmp endif

else:
    .....
    jmp endif  ; 实际上不是必需的，但为了完整性在此打印

endif:
```

在脑海中以高级方式思考，然后以这种方式将其转换为汇编。

有许多 `jmp` 条件：如果相等、如果小于等。它们非常直观，但你总是可以 Google 它们


调用函数
-----------------

正如你可能想到的，调用函数只是跳转到一个标签。

棘手的部分是参数。处理参数有两个步骤：

1. 程序员知道它们共享一个特定的寄存器或内存地址
2. 编写更多代码，使函数调用通用且无副作用

步骤 1 很容易。让我们同意我们将使用 `al`（实际上是 `ax`）作为参数。

```nasm
mov al, 'X'
jmp print
endprint:

...

print:
    mov ah, 0x0e  ; tty 代码
    int 0x10      ; 我假设 'al' 已经有了字符
    jmp endprint  ; 这个标签也是预先约定的
```

你可以看到这种方法很快就会变成意大利面条代码。当前的 `print` 函数只会返回到 `endprint`。如果其他函数想调用它怎么办？我们正在扼杀代码重用。

正确的解决方案提供了两个改进：

- 我们将存储返回地址，以便它可以变化
- 我们将保存当前寄存器，以允许子函数修改它们而没有任何副作用

为了存储返回地址，CPU 将帮助我们。不要使用一对 `jmp` 来调用子例程，而是使用 `call` 和 `ret`。

为了保存寄存器数据，还有一个使用栈的特殊命令：`pusha` 和它的兄弟 `popa`，它们自动将所有寄存器推入栈并在之后恢复它们。


包含外部文件
------------------------

我假设你是一个程序员，不需要说服你为什么这是一个好主意。

语法是
```nasm
%include "file.asm"
```


打印十六进制值
-------------------

在下一课中，我们将开始从磁盘读取，所以我们需要某种方式来确保我们正在读取正确的数据。文件 `boot_sect_print_hex.asm` 扩展了 `boot_sect_print.asm` 以打印十六进制字节，而不仅仅是 ASCII 字符。


代码！
-----

让我们跳到代码。文件 `boot_sect_print.asm` 是将被 `%include` 到主文件中的子例程。它使用循环在屏幕上打印字节。它还包括一个打印换行符的函数。熟悉的 `'\n'` 实际上是两个字节，换行符 `0x0A` 和回车符 `0x0D`。请尝试删除回车符并查看其效果。

如上所述，`boot_sect_print_hex.asm` 允许打印字节。

主文件 `boot_sect_main.asm` 加载几个字符串和字节，调用 `print` 和 `print_hex` 并挂起。如果你理解了前面的部分，这是相当直接的。
