
**目标：清理代码并解析用户输入**

在这节课中，我们将做两件事。首先，我们将稍微清理代码，使其为进一步的课程做好准备。在之前的课程中，我试图将东西放在最可预测的位置，但了解代码库何时增长并使其适应当前和未来的需求也是一个很好的练习。


代码清理
-------------

首先，我们将很快开始需要更多用于处理字符串等的实用函数。在常规操作系统中，这被称为 C 库，或简称 libc。

现在我们有一个 `utils.c`，我们将其拆分为 `mem.c` 和 `string.c`，以及它们各自的头文件。

其次，我们将创建一个新函数 `irq_install()`，以便内核只需要执行一次调用即可初始化所有 IRQ。该函数类似于 `isr_install()` 并放置在同一个 `irq.c` 中。
当我们在这里时，我们将禁用 `timer_callback()` 上的 `kprint()` 以避免用垃圾填充屏幕，现在我们知道它正常工作了。

`cpu/` 和 `drivers/` 之间没有明确的区别。请记住，我正在跟随许多其他教程创建本教程，每个教程都有不同的文件夹结构。我们现在唯一要做的更改是将 `drivers/ports.*` 移动到 `cpu/`，因为它显然是 cpu 相关的代码。
`boot/` 也是 CPU 相关的代码，但在我们为不同的机器实现引导序列之前，我们不会弄乱它。

`Makefile` 上的 `CFLAGS` 有更多开关，因为我们现在将开始为我们的 C 库创建更高级的函数，如果我们在声明中犯了错误，我们不希望编译器包含任何外部代码。我们还添加了一些标志将警告转换为错误，因为转换指针的看似轻微的错误可能会在以后爆炸。这也迫使我们修改代码中的一些杂项指针声明。

最后，我们将在 `libc/function.h` 上添加一个宏，以避免对未使用的参数发出警告错误

键盘字符
-------------------

那么如何访问键入的字符？

- 当按下键时，回调通过在 `keyboard.c` 开头定义的新数组获取 ASCII 代码
- 然后回调将该字符附加到缓冲区 `key_buffer`
- 它也会打印在屏幕上
- 当操作系统想要读取用户输入时，它调用 `libc/io.c:readline()`

`keyboard.c` 还解析退格，通过删除键缓冲区的最后一个元素，并通过调用 `screen.c:kprint_backspace()` 从屏幕上删除它。为此，我们需要稍微修改 `print_char()`，以便在打印退格时不前进偏移量


响应用户输入
------------------------

键盘回调检查换行符，然后调用内核，告诉它用户已输入了某些内容。我们的最终 libc 函数是 `strcmp()`，它比较两个字符串，如果它们相等则返回 0。如果用户输入"END"，我们停止 CPU。

这是有史以来最基本的 shell，但你应该感到自豪，因为我们从零开始实现了它。你意识到这有多酷吗？

如果你愿意，扩展 `kernel.c` 以解析更多内容。将来，当我们有文件系统时，我们将允许用户运行一些基本命令。
