*你可能想提前 Google 的概念：硬盘、柱面、磁头、扇区、进位位*

**目标：让引导扇区从磁盘加载数据以启动内核**

我们的操作系统不能放入引导扇区的 512 字节中，所以我们需要从磁盘读取数据以运行内核。

幸运的是，我们不必处理旋转盘片的开关，我们只需调用一些 BIOS 例程，就像我们在屏幕上打印字符一样。为此，我们将 `al` 设置为 `0x02`（以及其他需要的柱面、磁头和扇区的寄存器）并引发 `int 0x13`

你可以[在此处访问详细的 int 13h 指南](http://stanislavs.org/helppc/int_13-2.html)

在这一课中，我们将首次使用*进位位*，这是每个寄存器上存在的一个额外位，当操作溢出其当前容量时存储：

```nasm
mov ax, 0xFFFF
add ax, 1 ; ax = 0x0000 并且 carry = 1
```

进位不是直接访问的，而是由其他操作符用作控制结构，如 `jc`（如果进位位被设置则跳转）

BIOS 还将 `al` 设置为读取的扇区数，因此始终将其与预期数进行比较。


代码
----

打开并检查 `boot_sect_disk.asm` 以获取从磁盘读取的完整例程。

`boot_sect_main.asm` 为磁盘读取准备参数并调用 `disk_load`。注意我们如何编写一些实际上不属于引导扇区的额外数据，因为它在 512 位标记之外。

引导扇区实际上是 hdd 0 的磁头 0 的柱面 0 的扇区 1（第一个，扇区从 1 开始）。

因此，512 字节之后的任何字节都对应于 hdd 0 的磁头 0 的柱面 0 的扇区 2

主例程将用示例数据填充它，然后让引导扇区读取它。

**注意：如果你一直收到错误并且你的代码看起来很好，请确保 qemu 从正确的驱动器启动并相应地在 `dl` 上设置驱动器**

BIOS 在调用引导加载程序之前将 `dl` 设置为驱动器号。然而，我发现从 hdd 启动时 qemu 存在一些问题。

有两个快速选项：

1. 尝试使用标志 `-fda`，例如，`qemu -fda boot_sect_main.bin`，它将 `dl` 设置为 `0x00`，然后似乎工作正常。
2. 明确使用标志 `-boot`，例如 `qemu boot_sect_main.bin -boot c`，它自动将 `dl` 设置为 `0x80` 并让引导加载程序读取数据
